Ruta en local https: https://localhost:7100/
Resumen técnico de la API SpendingControl (contexto para frontend)
Autenticación y CORS:
•	Autenticación: JWT Bearer (Authorization: Bearer <token>)
•	Todas las rutas de controladores están protegidas con [Authorize]
•	Enumeraciones serializadas como string (JsonStringEnumConverter)
•	CORS permisivo (AllowAnyOrigin/Method/Header)
•	Swagger disponible en /
Filtros globales:
•	ModelValidationFilter: devuelve 400 con errores de modelo
•	ValidationExceptionFilter: captura excepciones de validación y devuelve 400
•	Se suprime el filtro automático de ModelState para usar el filtro personalizado
Controladores y endpoints:
MonetaryFundsController (/monetary-funds)
•	GET /monetary-funds: Lista fondos del usuario
•	GET /monetary-funds/{id}: Obtiene detalle (404 si no existe o no pertenece)
•	POST /monetary-funds: Crea fondo (201)
•	PUT /monetary-funds/{id}: Actualiza (204)
•	DELETE /monetary-funds/{id}: Elimina (204) DTO creación (MonetaryFundCreateDto): { name: string (1..200), type: "BankAccount" | "Cash", accountNumberOrDescription?: string (<=100), initialBalance: number >= 0 } Respuesta (MonetaryFundResponseDto inferida): { id: guid, name: string, type: string, accountNumberOrDescription?: string, initialBalance: number, currentBalance: number }
ExpensesController (/expenses)
•	GET /expenses?from&to&page&size: Lista encabezados con detalles
•	GET /expenses/{id}: Obtiene gasto por id (404 si no existe o no es del usuario)
•	POST /expenses: Crea gasto (201) y puede incluir warnings de sobregiro Creación (SpendingHeaderCreateDto): { monetaryFundId: guid, date: ISO date, merchantName?: string (<=200), observations?: string (<=1000), documentType: "Receipt" | "Invoice" | "Other", details: [ { expenseTypeId: number > 0, amount: number > 0, description?: string } // al menos 1 ] } Respuesta (SpendingHeaderResponseDto inferida): { id: guid, monetaryFundId: guid, date: ISO date, merchantName?: string, observations?: string, documentType: string, details: [ { id: guid, expenseTypeId: number, amount: number, description?: string } ], overdraftWarnings?: [ { expenseTypeName: string, budget: number, executed: number, overdraft: number } ] } Lógica especial:
•	IsValid se marca false si el fondo queda con balance negativo.
•	Si algún detalle causa sobregiro respecto al balance previo se devuelve warning.
•	Validaciones: mínimo 1 detalle, amount > 0, expenseTypeId > 0.
MovementsController (/movements)
•	GET /movements?from&to&page&size: Devuelve movimientos (MovementDto) agregando ambos tipos (no se muestran campos en código, el frontend debe consumir lo expuesto por Swagger).
ReportsController (/reports)
•	GET /reports/budget-vs-execution?from&to: Requiere ambos parámetros. Devuelve lista de BudgetVsExecutionItem (cada item contiene probablemente ExpenseTypeId/Name, Budget y Executed; revisar Swagger en ejecución).
Dominio relevante:
•	DocumentType: Receipt | Invoice | Other
•	FundType: BankAccount | Cash
•	MonetaryFund mantiene CurrentBalance (se modifica por retiros en creación de gastos).
•	SpendingHeader.TotalAmount = suma de detalles (no persistido)
•	OverdraftWarning: expenseTypeId, expenseTypeName, budget (balance previo), executed, overdraft.
Patrones de respuesta:
•	200 OK para lecturas
•	201 Created (Location + body) al crear
•	204 NoContent en update/delete sin cuerpo
•	400 BadRequest en validaciones (mensajes simples o lista según filtro)
•	401/403 en acceso a recursos de otro usuario
•	404 cuando entidad no existe
Parámetros comunes de paginación:
•	page (>=1, default 1)
•	size (>=1, default 50)
Formato de fechas:
•	from / to: DateTime (ISO 8601)
Encabezados requeridos:
•	Authorization: Bearer <token>
Ejemplo creación gasto: POST /expenses Authorization: Bearer xxx { "monetaryFundId": "guid", "date": "2025-01-15T00:00:00Z", "merchantName": "Comercio X", "observations": "Nota", "documentType": "Receipt", "details": [ { "expenseTypeId": 3, "amount": 120.50, "description": "Almuerzo" } ] }
Consideraciones frontend:
•	Mostrar warnings si vienen en overdraftWarnings
•	Mostrar enum como texto (ya viene serializado)
•	Manejar IsValid (si se expone posteriormente) para distinguir gastos válidos/invalidos en reportes
•	Ajustar paginación cliente con page/size
•	En creación de fondos validar unicidad del nombre (posible 400/409 con mensaje)
Swagger:
•	Usar / para redirect a /swagger
•	Revisar definiciones reales para MovementDto y BudgetVsExecutionItem antes de implementar UI final.
Fin.